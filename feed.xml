<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://liamt01.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://liamt01.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-05-14T00:18:55+00:00</updated><id>https://liamt01.github.io/feed.xml</id><title type="html">blank</title><subtitle>Personal website of Hongwei Tu, a Master&apos;s student in Computer Science at Carnegie Mellon University. </subtitle><entry><title type="html">Scaling Like a Pro: Zero Bubble Pipeline Parallelism Demystified</title><link href="https://liamt01.github.io/blog/2024/zero-bubble/" rel="alternate" type="text/html" title="Scaling Like a Pro: Zero Bubble Pipeline Parallelism Demystified"/><published>2024-11-26T00:00:00+00:00</published><updated>2024-11-26T00:00:00+00:00</updated><id>https://liamt01.github.io/blog/2024/zero-bubble</id><content type="html" xml:base="https://liamt01.github.io/blog/2024/zero-bubble/"><![CDATA[<h2 id="introduction">Introduction</h2> <p>Distributed training has become indispensable to deep learning, enabling researchers to scale models to billions and even trillions of parameters. Among the key strategies for distributing workloads across multiple GPUs is <strong>pipeline parallelism</strong>, a technique that splits a model into stages, with each stage assigned to a different device. Like an assembly line in manufacturing, pipeline parallelism allows multiple stages of a model to be processed simultaneously, improving throughput and making large-scale training feasible.</p> <p>However, pipeline parallelism is not without challenges. A major inefficiency stems from <strong>pipeline bubbles</strong>, which occur when devices are idle due to sequential dependencies between computation stages. These idle periods limit throughput and waste computational resources, particularly during the warm-up and flush phases of a pipeline. Over the years, several scheduling strategies, such as <strong>1F1B</strong> (one-forward-one-backward) <d-cite key="harlap2018pipedream, fan2021dapple, narayanan2021efficient"></d-cite>, have been developed to mitigate bubbles, but none have entirely eliminated them—until now.</p> <p>A recent paper, “Zero Bubble (Almost) Pipeline Parallelism” <d-cite key="qi2024zero"></d-cite>, introduces a breakthrough approach that achieves <strong>zero pipeline bubbles</strong> under synchronous training semantics. By splitting the backward pass into two parts: gradients with respect to <strong>inputs</strong> and gradients with respect to <strong>weights</strong>, the authors strategically place operations to fill bubbles and propose an <strong>automatic scheduling algorithm</strong>.</p> <p>In this post, we demystify the scheduling process, starting with the commonly used 1F1B approach and progressing to the zero-bubble schedules. Through <strong>step-by-step derivations and visualizations</strong>, we show how these schedules are constructed and highlight their key advantages. Finally, we explore how the insights from these schedules are generalized into an automatic scheduling algorithm. Whether you’re a seasoned ML systems researcher or new to distributed training, this post will provide clarity and context to help you understand the exciting potential of zero-bubble pipeline parallelism.</p> <h2 id="background">Background</h2> <h3 id="distributed-training-and-parallelism">Distributed Training and Parallelism</h3> <p>As deep learning models grow larger and more complex, training them on a single GPU becomes infeasible due to memory and compute constraints. Distributed training solves this problem by splitting the workload across multiple devices. The two most widely used parallelism strategies are <strong>data parallelism</strong> <d-cite key="goyal2017accurate, li2020pytorch"></d-cite> and <strong>model parallelism</strong> <d-cite key="harlap2018pipedream, huang2019gpipe, fan2021dapple, zheng2022alpa"></d-cite>.</p> <h4 id="data-parallelism">Data Parallelism</h4> <p>In data parallelism, the dataset is divided into smaller mini-batches, and identical copies of the model are deployed across multiple devices. Each device processes a different mini-batch, computes gradients, and synchronizes the results through an all-reduce operation.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-11-26-zero-bubble/data_parallelism.svg" sizes="95vw"/> <img src="/assets/img/2024-11-26-zero-bubble/data_parallelism.svg" class="img-fluid rounded z-depth-1 p-2" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> <figcaption class="caption">Data parallelism across four devices.</figcaption> </figure> <p>While simple and effective for small-to-medium-sized models, data parallelism struggles with memory-intensive models because it requires each device to store a complete copy of the model. In addition, the cost of communicating gradients grows with the number of devices, creating a bottleneck that can slow down training.</p> <h4 id="model-parallelism">Model Parallelism</h4> <p>In model parallelism, the model itself is split across devices, with each device responsible for a subset of the computations. Two common forms of model parallelism are:</p> <ul> <li><strong>Tensor parallelism</strong>: Splits tensors (e.g., weight matrices) within an operation across devices.</li> <li><strong>Pipeline parallelism</strong>: Divides the model into stages (layers), with each stage assigned to a device. Data flows through the stages sequentially, similar to an assembly line.</li> </ul> <h3 id="pipeline-parallelism">Pipeline Parallelism</h3> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-11-26-zero-bubble/pipeline_parallelism.svg" sizes="95vw"/> <img src="/assets/img/2024-11-26-zero-bubble/pipeline_parallelism.svg" class="img-fluid rounded z-depth-1 p-2" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> <figcaption class="caption">Pipeline parallelism across four devices.</figcaption> </figure> <p>Pipeline parallelism is particularly useful for training large models that exceed the memory capacity of a single GPU. By splitting the model into <strong>stages</strong> and the data into <strong>micro-batches</strong>, it enables simultaneous execution of forward and backward passes on different micro-batches and model layers. For example, while the first stage processes the forward pass for one micro-batch, the second stage can work on the backward pass for another micro-batch.</p> <p>However, pipeline parallelism introduces <strong>pipeline bubbles</strong>, which are idle periods that occur because:</p> <ol> <li>Stages must wait for data from preceding stages (sequential dependency).</li> <li>The warm-up and flush phases (described later) inherently result in under-utilized devices.</li> </ol> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-11-26-zero-bubble/bubbles.svg" sizes="95vw"/> <img src="/assets/img/2024-11-26-zero-bubble/bubbles.svg" class="img-fluid rounded z-depth-1 p-2" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> <figcaption class="caption">Bubbles in pipeline parallelism. Source: <a href="https://proceedings.neurips.cc/paper_files/paper/2019/file/093f65e080a295f8076b1c5722a46aa2-Paper.pdf">Gpipe</a>.</figcaption> </figure> <h2 id="the-1f1b-approach">The 1F1B Approach</h2> <p>To mitigate bubbles, practitioners have employed different <strong>scheduling strategies</strong>. One widely adopted strategy is <strong>1F1B</strong> (one-forward-one-backward), which alternates between forward and backward passes to balance workloads across devices.</p> <p>Before we dive into 1F1B, let’s consider a typical <strong>multi-layer perceptron (MLP)</strong> and how it is executed in a pipeline parallel setting:</p> <p> $$ \begin{align*} \pmb{z} &amp;= \mathbf{W}\pmb{x}\\ \pmb{y} &amp;= \sigma(\pmb{z})\\ \end{align*} $$ </p> <p>where \(\pmb{x}\) is the input, $\mathbf{W}$ is the weight matrix, $\sigma(\cdot)$ is the activation function, and \(\pmb{y}\) is the final output. We use the following notation:</p> <ul> <li><strong>Forward operation</strong>: $F_{i,k}$ for stage $i$ and micro-batch $k$.</li> <li><strong>Backward operation</strong>: <ul> <li><strong>$B_{i,k}$</strong>: Gradients with respect to <strong>inputs</strong> for stage $i$ and micro-batch $k$.</li> <li><strong>$W_{i,k}$</strong>: Gradients with respect to <strong>weights</strong> for stage $i$ and micro-batch $k$.</li> </ul> </li> </ul> <p>The computation graph for this MLP is shown below:</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-11-26-zero-bubble/computation_graph.svg" sizes="95vw"/> <img src="/assets/img/2024-11-26-zero-bubble/computation_graph.svg" class="img-fluid rounded z-depth-1 p-2" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> <figcaption class="caption">Computation graph for a typical MLP, including a forward pass and back-propagation.</figcaption> </figure> <p>We can see that the backward operation (both $B_{i,k}$ and $W_{i,k}$) must wait for the corresponding forward operation $F_{i,k}$ to complete.</p> <p>The 1F1B strategy combines the $B_{i,k}$ and $W_{i,k}$ into a single operation, resulting in the following dependency graph:</p> <div class="row mt-3 align-items-end"> <div class="col-sm-9 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-11-26-zero-bubble/dependency_graph_1.svg" sizes="95vw"/> <img src="/assets/img/2024-11-26-zero-bubble/dependency_graph_1.svg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> <figcaption class="caption">Dependency graph in 1F1B.</figcaption> </figure> </div> <div class="col-sm-3 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-11-26-zero-bubble/pattern.svg" sizes="95vw"/> <img src="/assets/img/2024-11-26-zero-bubble/pattern.svg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> <figcaption class="caption">Wavefront pattern for pipeline scheduling.</figcaption> </figure> </div> </div> <p>The dependency graph reveals a waveform pattern with three key components in pipeline scheduling:</p> <ol> <li><strong>From top-left to bottom</strong>: Process the forward pass for the same micro-batch across all stages.</li> <li><strong>To the right</strong>: Execute the backward pass at the current stage.</li> <li><strong>Back up to top-right</strong>: Propagate gradients backward to the preceding stage.</li> </ol> <p>1F1B scheduling follows this pattern and consists of three phases:</p> <ol> <li><strong>Warm-up phase</strong>: Pipeline stages incrementally begin processing forward passes for the incoming micro-batches. <strong>This phase inherently creates bubbles</strong> (idle periods) in the pipeline as downstream stages wait for data from upstream stages.</li> <li><strong>Steady state phase</strong>: Once the pipeline is fully loaded, each stage alternates between a <strong>forward pass</strong> ($F$) for a new micro-batch and a <strong>backward pass</strong> ($B$) for a previously processed micro-batch. This steady-state execution ensures that all pipeline stages remain busy.</li> <li><strong>Flush phase</strong>: The pipeline clears all in-flight micro-batches by completing the remaining backward passes while no new forward passes are introduced. <strong>Bubbles reappear at this stage</strong>, as upstream stages remain idle while waiting for downstream stages to finish processing.</li> </ol> <p>The figure below illustrates a 1F1B schedule with four stages (devices) and eight micro-batches. Note the wavefront pattern and the presence of bubbles:</p> <div class="l-body-outset"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-11-26-zero-bubble/naive_pipeline.svg" sizes="95vw"/> <img src="/assets/img/2024-11-26-zero-bubble/naive_pipeline.svg" class="img-fluid rounded z-depth-1 pt-2 pr-2" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> <figcaption class="caption">1F1B pipeline scheduling.</figcaption> </figure> </div> <p>1F1B is popular because it achieves a good balance between memory usage and throughput:</p> <ul> <li>By alternating forward and backward passes, it maintains a steady flow of computation, avoiding prolonged idle times during the steady state.</li> <li>The memory footprint is kept relatively low because the number of active micro-batches per stage is minimized.</li> </ul> <p>Despite its strengths, 1F1B has inherent limitations:</p> <ol> <li><strong>Tail-end bubbles in the flush phase</strong>: During the flush phase, no new forward passes are introduced, leaving upstream stages idle as they finish their computations.</li> <li><strong>Limited flexibility in operation placement</strong>: 1F1B strictly alternates forward and backward passes, leaving no flexibility to reorder operations strategically. This rigidity means that 1F1B cannot take advantage of opportunities to fill bubbles with other computations.</li> </ol> <p>In the next section, we will explore how splitting the backward pass into finer-grained components enables new schedules that significantly reduce or eliminate pipeline bubbles.</p> <h2 id="toward-zero-bubbles">Toward Zero Bubbles</h2> <p>The 1F1B schedule reduces bubbles to some extent, but it still leaves inefficiencies in the warm-up and flush phases. Remember that the backward pass consists of two components:</p> <ol> <li><strong>$B$</strong>: Gradients with respect to <strong>inputs</strong>.</li> <li><strong>$W$</strong>: Gradients with respect to <strong>weights</strong>.</li> </ol> <p>However, in 1F1B, $B$ and $W$ are grouped into a single operation, leading to sequential dependencies between $B_{i-1,k}$ and $W_{i,k}$.</p> <p>The key idea behind zero-bubble pipeline is to use <strong>finer-grained scheduling</strong>: splitting the backward pass into $B$ and $W$, which can be scheduled independently. This results in a refined dependency graph with more flexibility in operation placement:</p> <div class="row mt-3 align-items-end"> <div class="mx-auto col-sm-8 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-11-26-zero-bubble/dependency_graph_2.svg" sizes="95vw"/> <img src="/assets/img/2024-11-26-zero-bubble/dependency_graph_2.svg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> <figcaption class="caption">Dependency graph with finer granularity.</figcaption> </figure> </div> </div> <p>Unlike $F$ and $B$, which must remain sequentially dependent, $W$ can be flexibly scheduled to fill pipeline bubbles as long as it follows its corresponding $F$.</p> <p>Now, starting from the 1F1B schedule, let’s split the backward passes into $B$ and $W$. For simplicity, we assume that the execution times for $F$, $B$, and $W$ are identical.</p> <div class="l-body-outset"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-11-26-zero-bubble/pipeline_1.svg" sizes="95vw"/> <img src="/assets/img/2024-11-26-zero-bubble/pipeline_1.svg" class="img-fluid rounded z-depth-1 p-2" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <p>Thanks to the finer granularity, we can shift all operations on every stage except the last one to the left by one time step.</p> <div class="l-body-outset"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-11-26-zero-bubble/pipeline_2.svg" sizes="95vw"/> <img src="/assets/img/2024-11-26-zero-bubble/pipeline_2.svg" class="img-fluid rounded z-depth-1 p-2" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <p>We will see how the authors build on the above schedule by strategically placing operations, leading to two handcrafted schedules: <strong>ZB-H1</strong> and <strong>ZB-H2</strong>, which reduce or eliminate bubbles.</p> <h3 id="handcrafted-schedule-1-zb-h1">Handcrafted Schedule 1: ZB-H1</h3> <p>ZB-H1 adjusts the starting points of <strong>$W$</strong> passes, filling the tail-end bubbles with $W$ passes without exceeding the memory usage of 1F1B. As a result, the bubble size is reduced to approximately one-third of that in 1F1B.</p> <p>To better understand ZB-H1 in action, we will derive it step by step. First, let’s remove all $W$ operations from our starting point:</p> <div class="mx-auto" style="max-width: 350px;"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-11-26-zero-bubble/legend_finer.svg" sizes="95vw"/> <img src="/assets/img/2024-11-26-zero-bubble/legend_finer.svg" class="img-fluid" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="l-body-outset"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-11-26-zero-bubble/pipeline_3.svg" sizes="95vw"/> <img src="/assets/img/2024-11-26-zero-bubble/pipeline_3.svg" class="img-fluid rounded z-depth-1 p-2" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <p>In order to eliminate bubbles in the flush phase, we shift the last three stages to the left by one time step:</p> <div class="l-body-outset"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-11-26-zero-bubble/pipeline_3_1_1.svg" sizes="95vw"/> <img src="/assets/img/2024-11-26-zero-bubble/pipeline_3_1_1.svg" class="img-fluid rounded z-depth-1 p-2" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <p>To ensure the design of ZB-H1 meets its goals, we must carefully balance memory usage and computational dependencies while satisfying the following principles:</p> <ul> <li>The memory footprint must remain unchanged compared to the baseline.</li> <li>Sequential dependencies between $F$ and $B$ operations must be preserved.</li> <li>At least one $F$ operation must occur at every time step during the steady state phase, as backward passes ($B$) consume more memory than forward passes ($F$).</li> <li>Ideally, $W$ operations for the same micro-batch should follow a diagonal pattern, moving from the top left to the bottom right of the schedule. This spreads the workload evenly across time steps.</li> <li>There must be enough slots at each stage (eight per stage in this example) to accommodate all $W$ operations.</li> </ul> <p>We’ll further shift all operations to the left by reasonable amounts:</p> <div class="l-body-outset"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-11-26-zero-bubble/pipeline_3_1_2.svg" sizes="95vw"/> <img src="/assets/img/2024-11-26-zero-bubble/pipeline_3_1_2.svg" class="img-fluid rounded z-depth-1 p-2" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <p>We are almost there! Now, let’s reintroduce the $W$ operations and label their micro-batches correctly. We also extend the schedule to show the start of the next steady state phase:</p> <div class="l-page-outset"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-11-26-zero-bubble/pipeline_3_1_3.svg" sizes="95vw"/> <img src="/assets/img/2024-11-26-zero-bubble/pipeline_3_1_3.svg" class="img-fluid rounded z-depth-1 p-2" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <h4 id="key-trade-off">Key Trade-Off</h4> <p>ZB-H1 significantly reduces bubbles without increasing memory usage beyond 1F1B. However, it does not entirely eliminate bubbles, leaving some inefficiencies in the warm-up phase.</p> <h3 id="handcrafted-schedule-2-zb-h2">Handcrafted Schedule 2: ZB-H2</h3> <p>If we are willing to slightly relax the memory constraint, we can achieve <strong>zero bubbles</strong> by adding extra $F$ passes during the warm-up phase and reordering $W$ passes in the flush phase. This adjustment results in ZB-H2, which adopts a ‘‘parallelogram-shaped’’ layout that completely eliminates idle periods.</p> <p>Similarly to before, we begin by removing all $W$ operations to allow flexibility in rearranging other operations:</p> <div class="mx-auto" style="max-width: 350px;"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-11-26-zero-bubble/legend_finer.svg" sizes="95vw"/> <img src="/assets/img/2024-11-26-zero-bubble/legend_finer.svg" class="img-fluid" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="l-body-outset"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-11-26-zero-bubble/pipeline_3.svg" sizes="95vw"/> <img src="/assets/img/2024-11-26-zero-bubble/pipeline_3.svg" class="img-fluid rounded z-depth-1 p-2" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <p>We fill the warm-up phase with forward operations shifted from later time steps and move the remaining forward operations to the left accordingly:</p> <div class="l-body-outset"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-11-26-zero-bubble/pipeline_3_2_1.svg" sizes="95vw"/> <img src="/assets/img/2024-11-26-zero-bubble/pipeline_3_2_1.svg" class="img-fluid rounded z-depth-1 p-2" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <p>Now comes the crucial part: we carefully shift the steady-state operations to the left while respecting the sequential dependencies between $F$ and $B$ operations. Moreover, we sporadically reserve spots at earlier time steps for $W$ operations to ensure a balanced memory usage.</p> <div class="l-body-outset"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-11-26-zero-bubble/pipeline_3_2_2.svg" sizes="95vw"/> <img src="/assets/img/2024-11-26-zero-bubble/pipeline_3_2_2.svg" class="img-fluid rounded z-depth-1 p-2" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <p>Finally, let’s put $W$ operations back in place. Note how the pipeline achieves zero bubbles by transitioning from a trapezoidal layout (1F1B and ZB-H1) to a parallelogram layout:</p> <div class="l-page-outset"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-11-26-zero-bubble/pipeline_3_2_3.svg" sizes="95vw"/> <img src="/assets/img/2024-11-26-zero-bubble/pipeline_3_2_3.svg" class="img-fluid rounded z-depth-1 p-2" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <h4 id="key-trade-off-1">Key Trade-Off</h4> <p>ZB-H2 eliminates pipeline bubbles entirely and maximizes throughput. However, it requires additional memory due to:</p> <ul> <li>More active micro-batches during the warm-up phase.</li> <li>Delayed $W$ passes increasing peak memory usage.</li> </ul> <h2 id="automatic-zero-bubble-scheduling">Automatic Zero-Bubble Scheduling</h2> <p>While the handcrafted schedules ZB-H1 and ZB-H2 demonstrate the power of finer-grained scheduling, they rely on idealized assumptions, such as identical execution times for $F$, $B$, and $W$. Real-world models, however, often face variable execution times, heterogeneous hardware, and different memory constraints. To address this, the authors propose an <strong>automatic zero-bubble scheduling algorithm</strong>, which generalizes into a fully automated framework.</p> <h3 id="from-heuristics-to-automation">From Heuristics to Automation</h3> <p>Denote the running time of a backward pass as $T_B$. Drawing from the derivation of ZB-H2, the automatic scheduler dynamically adjusts the placement of operations based on the following principles:</p> <ol> <li>During the warm-up phase, schedule as many $F$ passes as possible to minimize the bubble before the first $B$.</li> <li>After the warm-up phase, alternate between one $F$ and one $B$, inserting $W$ operations to fill bubbles when gaps larger than $T_W$ occur. Additionally, insert $W$ operations to recycle memory when the memory limit is reached. Over time, this heuristic approach stabilizes into a steady-state 1$F$-1$B$-1$W$ pattern.</li> <li>At each stage, after all $F$ and $B$ passes are completed, schedule the remaining $W$ operations to clear the pipeline.</li> </ol> <p>Moreover, the communication time required to transfer activations or gradients between stages was ignored in the previous analysis. The authors address optimizer synchronization while maintaining synchronous semantics through an <strong>optimistic</strong> approach. This assumes that most training iterations proceed without numerical issues and that most synchronization steps on global states have no significant effect. Instead of relying on ad-hoc synchronization, the authors propose a <strong>post-hoc update validation</strong>:</p> <ol> <li>Before the optimizer step at each stage, a partially reduced global state from the previous stage is combined with the current stage’s local state and passed to the next stage.</li> <li>During the warm-up phase of the next iteration, the fully reduced global state is propagated back from the last stage to the first stage.</li> <li>Upon receiving the fully reduced global state, each stage validates whether the previous optimizer step needs to be invalidated and redone based on this complete state.</li> </ol> <h2 id="experiments-and-results">Experiments and Results</h2> <p>The authors conducted comprehensive experiments to evaluate the performance of their zero-bubble scheduling strategies, comparing the handcrafted and automatically generated schedules against baseline methods. The results demonstrate that zero-bubble scheduling consistently outperforms traditional approaches in both throughput and efficiency, with trade-offs between memory usage and performance.</p> <p>The experiments were implemented using the open-source Megatron-LM framework, trained models analogous to GPT-3, and were run on up to <strong>32 NVIDIA A100 GPUs</strong> distributed across 4 nodes.</p> <p>The authors compared the following scheduling strategies:</p> <ul> <li><strong>1F1B and 1F1B-I</strong>: Standard and interleaved 1F1B schedules. The interleaved variant (1F1B-I) splits the model into smaller chunks to reduce bubbles.</li> <li><strong>ZB-1p</strong>: Automatically searched schedule designed to match the peak memory usage of 1F1B while achieving much fewer bubbles.</li> <li><strong>ZB-2p</strong>: Automatically searched schedule with increased memory allowance (roughly twice that of 1F1B), enabling it to achieve nearly zero bubbles.</li> </ul> <p>Metrics evaluated include:</p> <ul> <li><strong>Throughput</strong>: Measured as the number of samples processed per second.</li> <li><strong>Bubble rate</strong>: Quantifies the proportion of idle time in the pipeline. A lower bubble rate indicates higher pipeline utilization.</li> <li><strong>Memory usage</strong>: Evaluated as the peak memory consumed per GPU during training.</li> </ul> <h3 id="key-findings">Key Findings</h3> <h4 id="throughput-performance">Throughput Performance</h4> <p><strong>ZB-2p</strong> consistently outperformed all other methods across various configurations, achieving throughput improvements of up to <strong>30%</strong> compared to 1F1B, even when using fewer micro-batches.</p> <p><strong>ZB-1p</strong> performed comparably to 1F1B-I in single-node setups but outperformed it in multi-node setups where communication bandwidth was a bottleneck. Its ability to reduce pipeline bubbles without communication overhead was a key advantage.</p> <h4 id="bubble-rate-analysis">Bubble Rate Analysis</h4> <p><strong>ZB-2p</strong> achieved a bubble rate of <strong>less than 1%</strong> in most setups. ZB-2p’s bubble rate was consistently lower than ZB-H2, showing the effectiveness of the automatic scheduling algorithm.</p> <p><strong>ZB-1p</strong>’s bubble rate was comparable to ZB-H1, where memory constraints become the dominant factor in limiting improvement.</p> <h4 id="memory-vs-performance-trade-offs">Memory vs. Performance Trade-Offs</h4> <p><strong>ZB-2p</strong> achieved the best throughput but required roughly <strong>twice</strong> the memory of 1F1B. Therefore, ZB-2p is more ideal for memory-rich setups.</p> <p><strong>ZB-1p</strong> matched the memory usage of 1F1B while achieving significant throughput gains, making it a more practical option with limited memory.</p> <h2 id="limitations">Limitations</h2> <p>Although zero-bubble scheduling shows promising results, we have identified several limitations.</p> <p>The handcrafted schedules ZB-H1 and ZB-H2 assume that the forward pass ($F$), backward pass for inputs ($B$), and backward pass for weights ($W$) have <strong>identical</strong> execution times. In practice, these times can vary significantly across layers and stages and can introduce additional bubbles.</p> <p>The automatic scheduling algorithm can struggle with highly <strong>heterogeneous device latencies or bandwidths</strong>. For example, devices with slower interconnects (e.g., PCIe instead of NVLink) or highly distributed setups (e.g., across multiple servers) can cause bottlenecks.</p> <p>The zero-bubble scheduling strategies assume a <strong>synchronous</strong> training setup, where all pipeline stages must remain in sync. This design ensures exact optimization semantics but limits applicability in asynchronous environments.</p> <h2 id="conclusion">Conclusion</h2> <p>Pipeline bubbles have long been a limiting factor in distributed training, reducing throughput and leaving computational resources under-utilized. The zero-bubble pipeline scheduling strategies presented in this paper mark a significant step forward, achieving higher throughput while maintaining synchronous training semantics.</p> <h3 id="contributions">Contributions</h3> <p>We summarize the key contributions of zero-bubble scheduling:</p> <ul> <li><strong>Finer-grained scheduling</strong>: By splitting the backward pass into gradients with respect to <strong>inputs</strong> ($B$) and <strong>weights</strong> ($W$), finer-grained scheduling introduces flexibility that reduces and even eliminates pipeline bubbles.</li> <li><strong>Automatic scheduling</strong>: The automatic zero-bubble scheduler adapts to real-world conditions, including heterogeneous execution times, hardware configurations, and memory constraints.</li> <li><strong>Integration with existing strategies</strong>: The proposed methods are orthogonal to other parallelism strategies like data parallelism (DP), tensor parallelism (TP), and ZeRO <d-cite key="rajbhandari2020zero"></d-cite>, and they can be integrated into hybrid training setups for further performance gains.</li> </ul> <h3 id="future-work">Future Work</h3> <p>While zero-bubble scheduling has demonstrated significant potential, we have identified several avenues for future research.</p> <p>Adapting the zero-bubble approach to <strong>asynchronous</strong> training settings could further improve scalability by eliminating synchronization requirements. This would require addressing challenges in managing dependencies and ensuring consistent optimization semantics. In addition, future work could focus on extending the automatic scheduler to handle highly <strong>heterogeneous</strong> environments, such as clusters with varying device speeds, memory capacities, and interconnect bandwidths.</p> <p>Investigating <strong>dynamic scheduling techniques</strong> that adapt in real-time to changing workloads or hardware conditions can optimize training efficiency. As <strong>hybrid parallelism strategies</strong> become common, integrating zero-bubble scheduling into DP or TP could lead to greater performance benefits.</p> <hr/> <p>Zero-bubble pipeline scheduling represents a significant advance in distributed training, demonstrating how finer-grained scheduling can boost throughput and resource utilization. This blog post builds on these ideas by providing detailed visualizations, contextual insights, and step-by-step clarity, making this complex topic more accessible. We hope these contributions help others better understand and apply zero-bubble scheduling, sparking more innovation in scalable deep learning systems.</p>]]></content><author><name>Hongwei Tu</name></author><category term="machine-learning"/><category term="distributed-training"/><category term="scaling"/><summary type="html"><![CDATA[Pipeline parallelism is key to efficient distributed training for large-scale models, but its performance is often hindered by pipeline bubbles, which are gaps in computation that limit throughput. A recent paper introduces a breakthrough zero-bubble scheduling strategy, achieving up to 30% throughput improvement. In this post, we demystify the scheduling process with detailed, step-by-step illustrations, providing clarity and context that complement the original work. Whether you're new to ML systems or a seasoned researcher, this post bridges the gap between high-level concepts and practical understanding with fresh and accessible perspectives.]]></summary></entry></feed>